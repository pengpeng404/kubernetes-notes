
### Namespace

Docker 在启动容器时，
实际上是在创建容器进程时候，
指定这个进程所需要的 Namespace 参数，
这样容器就只能看到当前 Namespace 所限定的资源、文件、设备、状态、或者配置，
对于宿主机以及其他的信息，
他就完全看不到了。

容器其实是一种特殊的进程。

容器启动的进程在他的 Namespace 中就是 1 号进程，
只能看到各自 Mount Namespace 里挂载的目录和文件，
只能访问到各自 Network Namespace 里的网络设备，
仿佛在一个个容器中。

#### Docker 启动容器会开启哪些 Namespace

- PID Namespace
  - 隔离进程 ID，使得容器内的进程具有独立的 PID。容器内的进程 PID 与主机不同，容器内的进程通常从 PID 1 开始
- Network Namespace
  - 隔离网络栈，使容器内的网络设备、IP 地址、路由表与主机分开。每个容器可以有自己的虚拟网卡和独立的网络环境
- Mount Namespace
  - 隔离文件系统挂载点，容器可以有独立的文件系统视图，可以通过挂载不同的目录结构而与主机系统隔离
- UTS Namespace
  - 隔离主机名和域名，使容器可以拥有自己的主机名（hostname）和域名（domain name），从而与主机区分开来
- IPC Namespace
  - 隔离信号量、消息队列和共享内存，使得容器的进程间通信与主机隔离
- User Namespace
  - 隔离用户和组 ID，使容器内的用户 ID 映射到主机上不同的 ID，从而提升安全性。在开启 User Namespace 后，可以让容器内运行为 root 的进程映射到主机上的非 root 用户


Namespace 问题 隔离不彻底 并且有些资源是无法 Namespace 隔离的

- 内核版本与内核模块
- 设备驱动
- 硬件资源
- 系统时间



### Cgroups Linux Control Group

限制一个进程组使用的资源上限，包括 CPU、内存、磁盘、网络带宽等


就是一个子系统目录加上一组资源限制文件的组合，
对于 Docker 容器来说，
只需要在每个子系统下面，
为每个容器创建一个控制组（即创建一个新目录），
在启动容器进程后，
把这个容器进程的 PID 写到控制组中的 tasks 文件中。



---

容器是一个“单进程”模型，
用户的应用进程就是容器中的 PID=1 的进程，
也是其他后续创建的所有进程的父进程。



### 容器镜像

Mount Namespace 修改的，
是容器进程对文件系统挂载点的认知，
也就意味着，
只有挂载这个操作发生之后，
进程的视图才会被改变。

我们可以在容器进程启动之前，
重新挂载他的整个根目录`/`，
这个挂载对宿主机不可见


而这个挂载在容器根目录上、用来为容器进程提供隔离后的执行环境文件系统，
就是所谓的“容器镜像”，
他还有一个更加专业的名字，
`rootfs`，根文件系统


---

对于 Docker 项目来说，
最核心的原理是为待创建的用户进程：
- 启用 Linux Namespace 配置
- 设置指定的 Cgroups 参数
- 切换进程的根目录（Change Root）



- 可读写层（rw）
- Init 层（ro+wh）
  - 存放 `etc/hosts` `etc/resolv.conf` 等信息
- 只读层（ro+wh）
  - 如果想删除只读层文件 这个删除操作实际上是在可读写层创建了 `.wh.xxxx` 的文件


---


```log
CMD ["python", "app.py"]
===================================
在 Dockerfile 中 完整的执行格式为 ENTRYPOINT CMD
但是在默认情况下 Docker 会提供一个隐含的 ENTRYPOINT 即 /bin/sh -c
所以在不指定 ENTRYPOINT 的时候 实际上是
/bin/sh -c "python app.py"
即 CMD 内容就是 ENTRYPOINT 参数
```



--- 

#### docker exec 实现原理

一个进程，
可以选择加入到某个进程已有的 Namespace 当中，
从而达到“进入”容器的目的



由于使用了联合文件系统，
在容器里对镜像 `rootfs` 所作的任何修改，
都会被操作系统先复制到可读写层，
然后再修改，
这就是所谓的写时复制






---


所以，一个Linux容器可以看成两个部分，
容器运行时和容器镜像，

- 容器运行时
  - 由 Namespace+Cgroups 构成的隔离环境
- 容器镜像
  - 联合挂载的根目录文件 rootfs




#### 数据存储卷 Volume

问题1：容器里进程新建的文件，如何才能让宿主机获取到？

问题2：宿主机上的文件和目录，如何才能让容器里的进程访问到？


在容器进程启动之后，
尽管开启了 Mount Namespace，
但是在切换根目录之前，
容器进程是可以一直看到宿主机上的整个文件系统的

在宿主机上也包含了我们的容器镜像，
这个镜像的各个层，
保存在 `var/lib/docker/aufs/diff` 目录下，
容器进程启动后，
他们会被联合挂载到 `var/lib/docker/aufs/mnt` 目录中，
这样容器的 `rootfs` 就准备好了

所以我们在 `rootfs` 准备好之后，
执行 chroot 之前，
把指定的宿主机文件目录挂载到指定的容器目录在宿主机上对应的目录上，
这个存储卷挂载的工作就完成了

注意：由于执行挂载操作的时候，
容器进程（init 进程）已经创建了，
也就意味着 Mount Namespace 已经开启，
所以这个挂载事件旨在这个容器里可见，
在宿主机上是看不到容器内部的挂载点的

















