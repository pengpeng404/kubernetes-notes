### 通道 channel



```go
ch := make(chan int, 3)
// 创建一个3缓冲的通道 元素类型为int
```


通道特性：
- 1、发送操作之间是互斥的、接受操作也是
  - 在同一时刻，对同一个通道的发送操作只能执行某一个，即使这些操作是并发执行的也是如此
  - 对于同一个通道的同一个元素，发送操作和接受操作也是互斥的，不会出现正在复制的元素被接受的一方看到
  - 元素值从外界进入通道时会被复制，进入通道的并不是操作的元素值，而是副本
  - 元素从通道进入外界时，分为两步，一是生成元素值的副本，二是删除在通道中的这个元素值
- 2、发送和接受操作对元素值的处理是不可分割的
  - 处理元素都是一体的，不会被打断
- 3、发送操作在完全完成之前会被阻塞，接受操作也是
    



非缓冲通道的数据是直接从发送方复制到接受方的，
中间并不会用非缓冲通道做中转



问题1：发送操作和接受操作在什么时候可能被长时间阻塞？

对于缓冲通道：
- 如果通道已满，所有的发送操作都会被阻塞，直到有元素被接受走
  - 所有发送的goroutine都会按照顺序进入通道内部的发送等待队列，所以通知的顺序是公平的
- 如果通道已空，所有接受操作都会被阻塞，直到有元素进来
  - 所有等待的、接受操作的goroutine都会按照先后顺序进入通道内部的接受等待队列

对于非缓冲通道：

无论是发送还是接受，都是阻塞的，直到配对的操作也开始执行，
并且数据是直接从发送方复制到接收方的，
中间并不会用非缓冲通道做中转

问题2：发送操作和接受操作什么时候会panic？

对于没有关闭的通道来说，
收发操作一定不会panic，
但是通道一旦关闭，
发送操作一定引发panic，
另外，我们试图关闭已经关闭了的通道，
也会panic

接受操作是可以感知到通道关闭的，
接受的时候同时付给两个变量，
第二个就是bool类型，
如果是false，说明通道关闭，并且已经没有元素了，
如果是true，说明还有元素，但是不清楚关没关
如果没有关闭，则会一直在这里阻塞



我们应当让发送方做关闭通道












